;****************************************************************
;*								*
;*	Copyright 2002, 2012 Fidelity Information Services, Inc	*
;*								*
;*	This source code contains the intellectual property	*
;*	of its copyright holder(s), and is made available	*
;*	under a license.  If you do not know the terms of	*
;*	the license, please stop and do not read further.	*
;*								*
;****************************************************************/

	.title	gtm_main	dispatch code for run-time system

	G_MSF
	base_frame

$CODE$	=	"GTM$INIT,QUAD,PIC,CON,REL,LCL,SHR,EXE,NOWRT"
$DATA$	=	"GTM$VECTOR,OCTA,PIC,OVR,REL,LCL,NOSHR,NOEXE,WRT"
$LINK$	=	"GTM$LINK,OCTA,NOPIC,CON,REL,LCL,NOSHR,NOEXE,WRT"


	$data_section
gtm_vector:
argcnt:			.long		<gtm_vector_end - gtm_vector>
rtn_start:		address_32	start
rtn_end:		address_32	end
zctable_start:		address_32	gtm$startzc
zctable_end:		address_32	gtm$endzc
zcpack_start:		address_32	gtm$startzcpack
zcpack_end:		address_32	gtm$endzcpack
vax_fp:			.long		0
xf_table:		.long		0
frm_ptr:		.long		0
base_addr:		.long		0
gtm_main_inaddr:	address_32	gtm$main
user_stack_size:	.long		GTM$USER_STACK_SIZE
user_spawn_flag:        .long           GTM$USER_SPAWN_FLAG
user_indrcache_size:	.long		GTM$USER_INDRCACHE_SIZE
user_strpl_size:	.long		GTM$USER_STRPL_SIZE
user_io_timer:		.long		GTM$USER_IO_TIMER
user_write_filter:	.long		GTM$USER_WRITE_FILTER
special_input:		.long		GTM$SPECIAL_INPUT
undef_inhib:		.long		GTM$UNDEF_INHIBIT
ctrlc_enable:		.long		GTM$CTRLC_ENABLE
break_message_mask:	.long		GTM$BREAK_MESSAGE_MASK
labels:			.long		GTM$LOWER_CASE_LABELS
lvnullsubs:		.long		GTM$LVNULLSUBS
zdir_form:		.long		GTM$ZDIR_FORM
zdate_form:		.long		GTM$ZDATE_FORM
sysid:			address_32	gtm_sysid_mstr
dlr_truth:		.long		0
gtm_vector_end = .

gtm_sysid_mstr:		.long		9		;These lines
			address_32	gtm_sysid	;		construct
gtm_sysid:		.ascii		"gtm_sysid"	; 				an mstr

;	These dummy PSECT's will be sorted (alphabetically) by the linker
;	to delimit the beginning and end of the initial routines name
;	(rtn_tables) table.  In order for this to work, they must have the
;	same significant attributes as those of the PSECT generated by
;	create_object_file (in obj_file.c) and must have alignment requirements
;	no more restrictive than those of rtn_tables.

;	GTM$R - beginning of initial routine tables
	.psect	gtm$r		pic,rel,gbl,noshr,noexe,rd,wrt,novec,long
	NUL = ^X00
	DEL = ^X7F
start:	.long	8			; length of start_rtn_name
	address_32 start_rtn_name
	.long	0			; dummy address

;	GTM$RZZZZZZZZZZZZZZZZZZZZZZZZZZ - end of initial routine tables plus some room for expansion
	.psect	gtm$rzzzzzzzzzzzzzzzzzzzzzzzzzz	pic,rel,gbl,noshr,noexe,rd,wrt,novec,long
end:	.long	8			; length of end_rtn_name
	address_32 end_rtn_name
	.long	0			; dummy address
	.blkl	17 * 3			; extra room for expansion (FREE_RTNTBL_SPACE * (sizeof(rtn_tables)/sizeof(long))) (BYPASSOK)

	.psect	gtm$rtn_literals pic,rel,gbl,shr,noexe,rd,nowrt,novec,quad
start_rtn_name:				; name guaranteed to sort before all others
	.ascii	<NUL><NUL><NUL><NUL><NUL><NUL><NUL><NUL>
	.align quad			; so the next name starts at 8-byte boundary
end_rtn_name:				; name guaranteed to sort after all others
	.ascii	<DEL><DEL><DEL><DEL><DEL><DEL><DEL><DEL>


;	gtm$main - GT.M initialization interface
;
;	The routine header for all GT.M object files contains code to transfer control
;	to gtm$main.  This code executes first whenever the GT.M object file is invoked
;	by VMS (e.g., as the first module in an executable image) in order to set up
;	the Alpha stack frame for GT.M and to ensure gtm$startup gets called to initialize
;	the GT.M environment properly.
;
;	Dynamically-linked GT.M object modules or those not the first to execute are
;	invoked at the address following the routine header and, so, do not invoke gtm$main.
;
;	gtm$main is invoked by the instruction sequence (see create_object_file in obj_file.c):
;		ldq	r0, gtm$main_linkage_pair(r27)
;		ldq	r1, gtm$main_linkage_pair+8(r27)
;		jmp	r0, (r0)
;	so that gtm$main can execute in its caller's stack frame (and initialize it).
;
;	Entry:
;		r0	return address in gtm$main's GT.M caller (just after jsb field in routine header)
;		r1	address of gtm$main's procedure descriptor

	$routine	gtm$main, entry=gtm$main_ca, kind=stack, -
			saved_regs=<%string(base_frame_regs)>, -
			base_reg_is_fp=true, data_section_pointer=true, -
			rsa_offset=RSA_OFFSET, size=STACK_SIZE, -
			standard_prologue=false, handler=GTM$DYN_CH, synch_exceptions=true

	create_base_frame	; special prologue code + extend stack for argument push area

	mov	r1,  r13
	.base	r13, $ls

;	init_gtm (<return address (just past jsb field in routine header)>, <caller's and our frame pointer>)
	mov	^x0, r18	; indicate that this is not a DAL case
	$call	init_gtm, local=true, nonstandard=true, set_arg_info=false, scratch_regs=<r28>, args=<r0, fp, r18>

	ldq	r22, $dp
	.base	r22, $ds

	ldl	r10, dlr_truth
	ldl	r11, xf_table
	ldl	r12, frm_ptr
	ldl	r8,  msf$l_symtab_off(r12)
	ldl	r9,  msf$temps_ptr_off(r12)
	ldl	r28, msf$rvector_off(r12)	; get routine header of GT.M MUMPS routine to invoke
	ldl	r13, mrt$lnk_ptr(r28)		; linkage Psect address not initialized by init_gtm -- obtain from routine header
	stl	r13, msf$ctxt_off(r12)
	ldl	r14, mrt$lit_ptr(r28)		; literal Psect address not initialized by init_gtm -- obtain from routine header
	stl	r14, msf$literal_ptr_off(r12)
	ldl	r26, msf$mpc_off(r12)

;	Don't do a normal $return; leave stack unchanged.
;	begin	pseudo-epilogue
	$begin_epilogue
	trapb					; synchronize exceptions
	ret	r26
	$end_epilogue
;	end	pseudo-epilogue

	$end_routine	name=gtm$main


;	init_gtm - invoke gtm$startup to initialize GT.M
;
;	init_gtm initializes some fields in the startup vector, gtm_vector,
;	and then invokes gtm$startup to complete GT.M environment
;	initialization.
;
;	args	a0 (r16)  - return address of GT.M caller
;			For a GT.M object module, this will be the
;			  address immediately following the call to
;			  gtm$main and will be in the routine header.
;			For a foreign-language routine, this should
;			  have been set to zero by gtm$init.
;
;		a1 (r17) - fp of condition handler
;			This is the frame pointer of the stack frame
;			that will contain the condition handler address.
;			For GT.M objects that call gtm$main, this will be
;			the first-invoked object module.
;			For foreign-language calls, this will be the
;			stack from for gtm$init.
;
;		a2 (r18) - flag that indicates whether this function was
;			invoked from gtm$main (0) or gtm$init (1)

	$routine	name=init_gtm, entry=init_gtm_ca, local=true, -
			standard_prologue=true, kind=stack, -
			base_reg_is_fp=true, saved_regs=<fp>, -
			data_section_pointer=true

	.base	r27, $ls
	ldq	r22, $dp
	.base	r22, $ds

	stl	r16, base_addr
	addq	r17, 8, r28	; add 8 to point to address of handler
	stl	r28, vax_fp
	$call	gtm$startup, args=<gtm_vector/A, r18>	; second parameter indicates whether this is DAL or not
	$return

	$end_routine	name=init_gtm


;	gtm$init - interface to GT.M for foreign-language routines
;
;	Foreign-language (non-GT.M) programs that wish to invoke GT.M
;	routines should call gtm$init first to invoke the GT.M initialization
;	code.

	$linkage_section
A_LIB$SIG_TO_RET:
	.address	LIB$SIG_TO_RET

	$routine	name=gtm$init, entry=gtm$init_ca, standard_prologue=true, kind=stack, -
			base_reg_is_fp=true, rsa_offset=24, saved_regs=<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,fp>, -
			handler=GTM$DYN_CH, synch_exceptions=true

	mov	r27, r13
	.base	r13, $ls

	ldq	r28, A_LIB$SIG_TO_RET
	stl	r28, 8(fp)	; establish LIB$SIG_TO_RET as handler
	mov	^x1, r18	; indicate that this is a DAL case
	$call	init_gtm, local=true, args=<r31, fp, r18>
	lda	r0, 1(r31)	; return success
	$return

	$end_routine	name=gtm$init

	.end
